#!/usr/bin/env python3
"""
compile.py - Nim compiler wrapper for USB Goose payloads

This script compiles Nim payloads to C and then uses LLVM/Clang 
to generate target-specific ELF files.
"""

import os
import sys
import argparse
import subprocess
import tempfile
import shutil
from pathlib import Path

# Define target-specific settings
TARGETS = {
    "ch569": {
        "triple": "riscv32-unknown-none-elf",
        "cpu": "rv32imac",
        "abi": "ilp32",
        "defines": ["CH569", "RISCV", "USE_USB3"],
        "include_dirs": ["../../firmware/common/include", "../../firmware/ch569/include"],
        "linker_script": "../../firmware/ch569/ch569_payload.ld"
    },
    "esp32c6": {
        "triple": "riscv32-unknown-none-elf",
        "cpu": "rv32imc",
        "abi": "ilp32",
        "defines": ["ESP32C6", "ESP_PLATFORM"],
        "include_dirs": ["../../firmware/common/include", "../../firmware/esp32c6/include"],
        "linker_script": "../../firmware/esp32c6/esp32c6_payload.ld"
    }
}

def ensure_nim():
    """Check if Nim is installed, give instructions if not."""
    try:
        subprocess.check_call(["nim", "--version"], stdout=subprocess.DEVNULL)
        return True
    except (subprocess.SubprocessError, FileNotFoundError):
        print("Nim compiler not found. Please install Nim:")
        print("  - On Linux/macOS: curl https://nim-lang.org/choosenim/init.sh -sSf | sh")
        print("  - On Windows: https://nim-lang.org/install_windows.html")
        return False

def compile_nim_to_c(nim_file, output_dir, target):
    """Compile Nim to C."""
    # Create output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # Generate output C filename
    basename = os.path.basename(nim_file)
    c_dir = os.path.join(output_dir, "nimcache")
    
    # Create nim.cfg for cross-compilation settings
    nim_cfg = os.path.join(output_dir, "nim.cfg")
    with open(nim_cfg, 'w') as f:
        f.write(f"""--cpu:"{TARGETS[target]['cpu']}"
--os:standalone
--gc:none
--threads:off
--opt:size
--passC:"-target {TARGETS[target]['triple']} -mabi={TARGETS[target]['abi']}"
--passL:"-target {TARGETS[target]['triple']} -mabi={TARGETS[target]['abi']}"
""")
    
    # Compile Nim to C
    cmd = [
        "nim", "c",
        "--nimcache:" + c_dir,
        "--compileOnly",
        "--header",
        "--noMain",
        "--noLinking",
        "--config:" + nim_cfg,
        nim_file
    ]
    
    print(f"Compiling {nim_file} to C...")
    subprocess.check_call(cmd)
    
    # Find generated C file
    c_files = list(Path(c_dir).glob("*.c"))
    if not c_files:
        raise RuntimeError("No C files generated by Nim compiler")
    
    # Return the path to the generated C file
    return str(c_files[0])

def compile_c_to_elf(c_file, target, output_file=None):
    """Compile C to ELF using LLVM/Clang."""
    # Get target settings
    target_settings = TARGETS[target]
    
    # Set output filename if not specified
    if output_file is None:
        basename = os.path.basename(c_file)
        output_file = os.path.splitext(basename)[0] + ".elf"
    
    # Build include directory arguments
    include_args = []
    for include_dir in target_settings["include_dirs"]:
        include_args.extend(["-I", include_dir])
    
    # Build define arguments
    define_args = []
    for define in target_settings["defines"]:
        define_args.append(f"-D{define}")
    
    # Get the directory where bindings.c is located
    bindings_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "bindings.c")
    
    # Build clang command
    clang_cmd = [
        "clang",
        "-target", target_settings["triple"],
        f"-mcpu={target_settings['cpu']}",
        f"-mabi={target_settings['abi']}",
        "-O2",
        "-ffunction-sections",
        "-fdata-sections",
        "-nostdlib",
        "-ffreestanding",
        *include_args,
        *define_args,
        "-T", target_settings["linker_script"],
        "-o", output_file,
        c_file,
        bindings_file,
        "-Wl,--gc-sections",
    ]
    
    # Execute clang
    print(f"Compiling {c_file} for {target}...")
    subprocess.check_call(clang_cmd)
    
    return output_file

def main():
    parser = argparse.ArgumentParser(description="Compile Nim payloads to ELF files")
    parser.add_argument("nim_file", help="Nim file to compile")
    parser.add_argument("--target", choices=TARGETS.keys(), default="ch569", help="Target chip")
    parser.add_argument("--output", "-o", help="Output ELF file")
    parser.add_argument("--keep-c", action="store_true", help="Keep generated C file")
    args = parser.parse_args()
    
    # Ensure Nim is installed
    if not ensure_nim():
        return 1
    
    # Create temporary directory
    with tempfile.TemporaryDirectory() as temp_dir:
        # Compile Nim to C
        c_file = compile_nim_to_c(args.nim_file, temp_dir, args.target)
        
        # Compile C to ELF
        elf_file = compile_c_to_elf(c_file, args.target, args.output)
        
        # Copy resulting ELF file if output directory is different
        if args.output and os.path.dirname(args.output) != temp_dir:
            os.makedirs(os.path.dirname(args.output), exist_ok=True)
            shutil.copy2(os.path.join(temp_dir, os.path.basename(elf_file)), args.output)
        
        # Copy C file if requested
        if args.keep_c:
            c_dest = os.path.splitext(elf_file)[0] + ".c"
            shutil.copy2(c_file, c_dest)
            print(f"C file saved to: {c_dest}")
    
    print(f"Compiled ELF file: {elf_file}")
    return 0

if __name__ == "__main__":
    sys.exit(main())